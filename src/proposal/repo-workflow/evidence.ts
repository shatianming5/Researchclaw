import fs from "node:fs/promises";
import path from "node:path";
import type { ProposalExecuteResult } from "../execute/types.js";
import type { PlanDag, PlanNode } from "../schema.js";
import type { HostCommandRunner } from "./git.js";
import type { RepoWorktreeRecord } from "./types.js";
import type { RepoWorkflowEvidence, RepoWorkflowManifest } from "./types.js";
import { writeJsonFile, writeTextFile } from "../files.js";
import { gitDiffPatch, gitDiffStat, gitHeadSha, gitIsDirty, gitRemoteOriginUrl } from "./git.js";

function normalizeRelPath(relPath: string): string {
  return relPath.trim().replaceAll("\\", "/");
}

function renderPrBody(params: {
  planId: string;
  planDir: string;
  repo: RepoWorkflowEvidence;
  executedNodes: PlanNode[];
  execute: ProposalExecuteResult;
}): string {
  const lines: string[] = [];
  lines.push(`# Proposal ${params.planId}: ${params.repo.repoKey}`);
  lines.push("");
  lines.push("## Summary");
  lines.push("");
  lines.push("- Generated by OpenClaw proposal execute (repo workflow evidence).");
  lines.push(`- Plan dir: \`${params.planDir}\``);
  if (params.repo.remoteUrl) {
    lines.push(`- Repo: \`${params.repo.remoteUrl}\``);
  }
  lines.push(`- Branch: \`${params.repo.branchName}\``);
  lines.push(`- Base: \`${params.repo.baseSha}\``);
  if (params.repo.headSha) {
    lines.push(`- Head: \`${params.repo.headSha}\``);
  }
  lines.push("");

  lines.push("## Evidence");
  lines.push("");
  lines.push(`- Diff patch: \`${params.repo.outputs.diffPatch}\``);
  lines.push(`- Diff stat: \`${params.repo.outputs.diffStat}\``);
  lines.push(`- Execute summary: \`${params.execute.paths.executeSummary}\``);
  lines.push(`- Execute log: \`${params.execute.paths.executeLog}\``);
  lines.push("");

  lines.push("## Repro");
  lines.push("");
  lines.push(`- \`${params.repo.outputs.reproScript}\``);
  lines.push("");

  if (params.executedNodes.length > 0) {
    lines.push("## Nodes executed for this repo");
    lines.push("");
    for (const node of params.executedNodes) {
      lines.push(`- \`${node.id}\` (${node.type})`);
    }
    lines.push("");
  }

  lines.push("## Suggested PR commands (manual)");
  lines.push("");
  lines.push("```sh");
  lines.push(`# From the plan dir: ${params.planDir}`);
  lines.push(`cd "${params.repo.worktreeRel}"`);
  lines.push("git status --porcelain=v1");
  lines.push("git diff --stat");
  lines.push("");
  lines.push("# Optional: commit + push (requires credentials)");
  lines.push("git add -A");
  lines.push(`git commit -m "proposal(${params.planId}): update ${params.repo.repoKey}" || true`);
  lines.push(`git push -u origin "${params.repo.branchName}"`);
  lines.push("");
  lines.push("# Optional: create PR (requires gh)");
  lines.push(
    `gh pr create --title "proposal(${params.planId}): ${params.repo.repoKey}" --body-file "${params.repo.outputs.prBody}"`,
  );
  lines.push("```");
  lines.push("");

  return `${lines.join("\n")}\n`;
}

function renderReproScript(params: {
  planId: string;
  repo: RepoWorkflowEvidence;
  nodes: PlanNode[];
}): string {
  const lines: string[] = [];
  lines.push("#!/usr/bin/env bash");
  lines.push("set -euo pipefail");
  lines.push("");
  lines.push('PLAN_DIR="${PLAN_DIR:-$(cd "$(dirname "$0")/../../.." && pwd)}"');
  lines.push(`WORKTREE="$PLAN_DIR/${normalizeRelPath(params.repo.worktreeRel)}"`);
  lines.push('cd "$WORKTREE"');
  lines.push("");
  lines.push(`# Repo workflow repro for plan ${params.planId}`);
  lines.push("");
  for (const node of params.nodes) {
    const cmds = node.commands ?? [];
    if (cmds.length === 0) {
      continue;
    }
    lines.push(`# Node: ${node.id} (${node.type})`);
    for (const cmd of cmds) {
      const trimmed = String(cmd ?? "").trim();
      if (!trimmed) {
        continue;
      }
      lines.push(trimmed);
    }
    lines.push("");
  }
  return `${lines.join("\n")}\n`;
}

function isRepoNodeForKey(node: PlanNode, repoKey: string): boolean {
  const input = normalizeRelPath(node.inputs?.[0] ?? "");
  return input === `cache/git/${repoKey}` || input.startsWith(`cache/git/${repoKey}/`);
}

export async function writeRepoWorkflowEvidence(params: {
  planDir: string;
  planId: string;
  dag: PlanDag;
  execute: ProposalExecuteResult;
  records: RepoWorktreeRecord[];
  executedNodeIdsByRepoKey: Map<string, string[]>;
  runHostCommand: HostCommandRunner;
}): Promise<{ manifestPath: string; manifest: RepoWorkflowManifest }> {
  const planDir = path.resolve(params.planDir);
  const createdAt = new Date().toISOString();

  const evidences: RepoWorkflowEvidence[] = [];
  for (const record of params.records) {
    const evidenceDirRel = path.join("report", "repo_workflow", record.repoKey);
    const evidenceDirAbs = path.join(planDir, evidenceDirRel);
    await fs.mkdir(evidenceDirAbs, { recursive: true });

    const remoteUrl = await gitRemoteOriginUrl(params.runHostCommand, record.worktreeAbs);
    const headSha = await gitHeadSha(params.runHostCommand, record.worktreeAbs);
    const dirtyAfter = await gitIsDirty(params.runHostCommand, record.worktreeAbs);
    const diffPatch = await gitDiffPatch(params.runHostCommand, record.worktreeAbs, record.baseSha);
    const diffStat = await gitDiffStat(params.runHostCommand, record.worktreeAbs, record.baseSha);

    const outputs = {
      repoJson: path.join(evidenceDirRel, "repo.json"),
      diffPatch: path.join(evidenceDirRel, "diff.patch"),
      diffStat: path.join(evidenceDirRel, "diff.stat.txt"),
      prBody: path.join(evidenceDirRel, "pr_body.md"),
      reproScript: path.join(evidenceDirRel, "repro.sh"),
    };

    const repoEvidence: RepoWorkflowEvidence = {
      repoKey: record.repoKey,
      repoRel: record.repoRel,
      remoteUrl: remoteUrl ?? undefined,
      branchName: record.branchName,
      baseSha: record.baseSha,
      headSha: headSha ?? undefined,
      dirtyAfter: dirtyAfter ?? undefined,
      worktreeRel: record.worktreeRel,
      evidenceDirRel,
      outputs,
    };

    const executedNodeIds = params.executedNodeIdsByRepoKey.get(record.repoKey) ?? [];
    const nodes = params.dag.nodes.filter((n) => executedNodeIds.includes(n.id));
    const prBody = renderPrBody({
      planId: params.planId,
      planDir,
      repo: repoEvidence,
      executedNodes: nodes,
      execute: params.execute,
    });
    const repro = renderReproScript({ planId: params.planId, repo: repoEvidence, nodes });

    await writeJsonFile(path.join(planDir, outputs.repoJson), {
      createdAt,
      planId: params.planId,
      repoKey: record.repoKey,
      repoRel: record.repoRel,
      worktreeRel: record.worktreeRel,
      branchName: record.branchName,
      remoteUrl,
      baseSha: record.baseSha,
      headSha,
      dirtyAfter,
      outputs,
    });
    await writeTextFile(path.join(planDir, outputs.diffPatch), diffPatch);
    await writeTextFile(path.join(planDir, outputs.diffStat), diffStat);
    await writeTextFile(path.join(planDir, outputs.prBody), prBody);
    await writeTextFile(path.join(planDir, outputs.reproScript), repro);
    await fs.chmod(path.join(planDir, outputs.reproScript), 0o755);

    evidences.push(repoEvidence);
  }

  // Also include repos referenced in the DAG but not executed with a worktree (informational).
  for (const node of params.dag.nodes) {
    const input = normalizeRelPath(node.inputs?.[0] ?? "");
    if (!input.startsWith("cache/git/")) {
      continue;
    }
    const repoKey = input.slice("cache/git/".length).replace(/^\/+/, "");
    if (!repoKey) {
      continue;
    }
    if (evidences.some((e) => e.repoKey === repoKey)) {
      continue;
    }
    if (!isRepoNodeForKey(node, repoKey)) {
      continue;
    }
    // No worktree record => repo wasn't modified (or execution stopped before).
  }

  const manifest: RepoWorkflowManifest = {
    planId: params.planId,
    createdAt,
    repos: evidences,
  };
  const manifestPath = path.join(planDir, "report", "repo_workflow", "manifest.json");
  await fs.mkdir(path.dirname(manifestPath), { recursive: true });
  await writeJsonFile(manifestPath, manifest);
  return { manifestPath, manifest };
}
